

# 全探索

## 基本は全通りを調べられないかを考える
- 1(答えで二分探索)
  - 実装は中身を参照のこと
- 2(小さい制約は全探索、bit全探索)
- 3(木の直径は最短距離計算を２回行う)
  - N頂点、N-1の辺の連結なグラフ
  - 頂点u-vにいく単純パスはただ１つだけ存在する
  - 頂点uとvを双方向に結ぶ辺を一本追加するとき閉路は１つ存在し、長さはu->vの単純パスの長さ＋１

- 4(前計算, 累積和)
- 7(ソートからの二分探索)
- 10(区間の総和->累積和)
- 12(連結判定はUnion -Find)
- 14(ソートして貪欲法)
- 16(全探索工夫)
- 18(三角関数を使いこなす)
  - math.sin, math.cos, math.pi, math.atan...
- 20(整数で考えて誤差を生まないように)
- 22(最大公約数はユークリッド)
- 24(偶奇を考えて、パリティを考慮する)
- 27(map, 辞書を使いこなす)
- 28
  - stackで実装するやり方（再帰制限を回避)
  - 再帰処理で実装
- 32(小さい制約は順列全探索)
  - list(itertools.permutations([i for i in range(n)]))
- 33(コーナーケースに気をつける)
  - 特定の場合に条件から外れる場合を抜け漏れないように
- 34（単調性を利用した尺取りほう)
- 36(マンハッタン距離は４５度回転)
  - X' = x - y
  - Y' = x + y
  - 回転後の二点間のマンハッタン距離は max(|X' - px|, |y' - py|)
- 39(答えへの貢献度を考える)
  - 和の形の数え上げを見たら主客転倒ができないかを念頭に置いて考える
  - 木DPという部分木の足し合わせについて考える。
  - 主客転置
    - 問題文で提示された求め方を別の意味に捉える。
  - コストが積の形になっているものも何らかの和の形に落とし込むと上手く行く場合がある。
- 42(9の倍数に着目)
  - 要復習
  - わかったようでなかなか完璧に理解し切れていない。
  - 今回のケースだと桁の和がXの時のDPをとる
  - XのDPになるためには１〜９個前のDPを加算すればいい→なぜ？
    - 例えば　３のケースは 111 21 12 3の４パターンある
    - 4のケースを作ろうとすると 3, 2, 1, 0 のケースの足し合わせである。
    - 例えば0のケースは４をつけるだけなので１通り
    - 1のケースは1に対して先頭につけるか後ろにつけるかで 1 3 or 3 1のにパターンあるが、これを先頭にのみつけていくことを考えれば重複しない(3,1のみをとる)
    - 1,3のケースは　3の時のケースでカバーできる（３は　3 12 21 111の４パターンあり、その先頭のパターンが該当する。
    - つまり結局のところ直前の和の作り方でできた整数の先頭に１〜９のいずれかを足すことで目的の値になる。
- 46(同じ意味のものをまとめる)
  - 今回は46で割ったあまりに注目して10^9まである範囲を46までの範囲に絞り込む。
- 55(定数倍を見積もる):
  - 低数倍の大きさによってACできたりできなかったりする。
  - pythonの場合でcombinationをつかうばあい、リストでそのまま取り出すようにしないと死ぬ。
- 61(deque)
  - dequeを使うことで計算量を落とす、ライブラリでもあるし自前で挿入時にtopとtailを動かせば良い
- 70(マンハッタン、x,y を独立に考える)
  - 今回は回転させる必要なし
  - 絶対値の和の最小は配列の**中央値**である。
- 75(√nの素因数分解)
- 76(円環は二倍して広げる)
  - 実戦では尺取り法で実装(N)
  - Lを決め打ちRを二分探索から拾う方法もある（NlogN)
  - 事前に広げた時に各店までの累積話をとっておくことでLRを決め打った時の値をO(1）で計算できる。
- 78(グラフの基本)
  - 基本は隣接行列N^2必要、 隣接リスト、Nだけしかいらない。
  - 

## 全体進行率

- 27/90
- レベル2
  - 9/10
- レベル3
  - 11/20
- レベル4
  - 6/14
- レベル5
  - 2/17
- レベル6
  - 0/14
- レベル7
  - 0/15


# 全探索

## 基本は全通りを調べられないかを考える
- 1(答えで二分探索)
  - 実装は中身を参照のこと
- 2(小さい制約は全探索、bit全探索)
- 3(木の直径は最短距離計算を２回行う)
  - N頂点、N-1の辺の連結なグラフ
  - 頂点u-vにいく単純パスはただ１つだけ存在する
  - 頂点uとvを双方向に結ぶ辺を一本追加するとき閉路は１つ存在し、長さはu->vの単純パスの長さ＋１
- 4(前計算, 累積和)
- 7(ソートからの二分探索)
- 6(辞書順最小は貪欲的に)
  - 辞書順最小は貪欲的に選択していくのがベスト
  - 例えば aa*** はab****であればaaが最小になるため、常に次に辞書順最小の文字を置けるかどうかを確かめておければおく、という選択がベストになる。
  - 置けるかどうかはその文字を選択した時、その右隣にある文字から最後まで選択（残りの文字全て）した時、残り置かなければならない文字数以上であればおけることになる。
- 8(耳DP、状態千位になれる)
  - 最初の初期化で要注意。
- 10(区間の総和->累積和)
- 12(連結判定はUnion -Find)
- 13(経路の重み最小値はダイクストラ)
  - （V+M)log(M)のアルゴリズムで優先度付きキューを使用する。
  - ライブラリがあるので使うこと。
  - 解放として、Xを経由させる必要があるので、1->X X->Nまでの最短を求めておいて足し合わせることで答えを出す。
  - 
- 14(ソートして貪欲法)
- 15(調和級数)
  - n //i の総和がnlogn程度にしかならないことをうまく利用する。
- 16(全探索工夫)
- 18(三角関数を使いこなす)
  - math.sin, math.cos, math.pi, math.atan...
- 20(整数で考えて誤差を生まないように)
- 22(最大公約数はユークリッド)
- 21(強連結成分分解)
  - お互いに行き来できる場合同じグループ
  - お互いに行き来できない場合異なるグループ
  - に分解することを強連結成分分解と呼ぶ。
  - アルゴリズムとしては任意の頂点からBFSで辿り、帰りがけで昇順で番号を振る
  - 次に、その番号が大きい順に、全ての辺の向きを反転させたグラフでBFSを行う。一回で辿れる領域が１つのグループになる
  - 計算量は全ての頂点Vと辺Eを一度ずつ渡るためO(V+E)になる
- 24(偶奇を考えて、パリティを考慮する)
- 27(map, 辞書を使いこなす)
- 28
  - stackで実装するやり方（再帰制限を回避)
  - 再帰処理で実装
- 30(約数列挙)
  - 素因数列挙には試し割りとエラトスてネスのにパターンがあるが、
  - 1〜n全てで何かをする問題ではエラトステネスが有効。
  - nで計算した配列を一度だけ用意すれば良い
- 31(Grundy数)
  - 必勝ゲームの求め方。各状態を列挙して xorを取ることで求まる。
- 32(小さい制約は順列全探索)
  - list(itertools.permutations([i for i in range(n)]))
- 33(コーナーケースに気をつける)
  - 特定の場合に条件から外れる場合を抜け漏れないように
- 34（単調性を利用した尺取りほう)
- 36(マンハッタン距離は４５度回転)
  - X' = x - y
  - Y' = x + y
  - 回転後の二点間のマンハッタン距離は max(|X' - px|, |y' - py|)
- 37(DPをセグメント木で高速化)
  - 超難しい
  - D Pで気をつけるべきは初期値、不可能な場合に判別できるように−１などで全体を初期化する
  - ただし、この時、〇番目の値を用いる場合はその列を０で初期化しておくなど、使えるけど使っていない状態と、そもそもその枠を使えないケースを区別しておく。
  - テーマは３重ループの中身をよくみると、その中での最大値を取得して値を更新するため、DPの一次元をセグメント木で管理することにより、最大値の取得を O(Log W)で行うことで計算量を削減するのがポイントになる。
- 38(オーバーフローに注意)：
  - 最小公倍数を求める問題で、最小こう倍数は 最大公約数をgcdを利用して a * b // gcdで求めることができる
  - この時gcdはユークリッドの互除法を利用することで、log(a+b)の計算量で求められる。
  - Pythonではa*bの時にオーバーフローしても多倍数を扱えるので問題ない。
- 39(答えへの貢献度を考える)
  - 和の形の数え上げを見たら主客転倒ができないかを念頭に置いて考える
  - 木DPという部分木の足し合わせについて考える。
  - 主客転置
    - 問題文で提示された求め方を別の意味に捉える。
  - コストが積の形になっているものも何らかの和の形に落とし込むと上手く行く場合がある。
- 42(9の倍数に着目)
  - 要復習
  - わかったようでなかなか完璧に理解し切れていない。
  - 今回のケースだと桁の和がXの時のDPをとる
  - XのDPになるためには１〜９個前のDPを加算すればいい→なぜ？
    - 例えば　３のケースは 111 21 12 3の４パターンある
    - 4のケースを作ろうとすると 3, 2, 1, 0 のケースの足し合わせである。
    - 例えば0のケースは４をつけるだけなので１通り
    - 1のケースは1に対して先頭につけるか後ろにつけるかで 1 3 or 3 1のにパターンあるが、これを先頭にのみつけていくことを考えれば重複しない(3,1のみをとる)
    - 1,3のケースは　3の時のケースでカバーできる（３は　3 12 21 111の４パターンあり、その先頭のパターンが該当する。
    - つまり結局のところ直前の和の作り方でできた整数の先頭に１〜９のいずれかを足すことで目的の値になる。
- 43(ダイクストラと0-1BFS)
  - ダイクストラは勉強
  - 01BFS辺の重みを１として扱う。この時、辺の重み１を使用した場合、なるべくコストを小さくしたい時にはすぐに探索する必要がないため後回しでappendrightにしておく。
  - また、今回の問題では向きが重要であるため、同じコストでもその地点を通過するときにどの向きで来たかでそれ以降のコストが変動する場合があるため、異なる向きの同じコストのパターンは次回のキューに差し込む必要がある。
- 44(見かけの変化を記録する)
  - 配列の位置を変換するようなものについてその交換した回数などを記録しておくだけで答えられる問題がある。
- 46(同じ意味のものをまとめる)
  - 今回は46で割ったあまりに注目して10^9まである範囲を46までの範囲に絞り込む。
- 48(上階と下界を見積る)
  - これ以上の答えが絶対にありえないような上階値を考えてみる。その後、実際に上階とな流答えや方法を構成する
- 51(半分前列挙)
  - 制約が40前後は 2^20 ずつに分けて全探索を試みる。
  - この時、掛け算なのか足し算なのかを気をつけて、片方はソートして二分探索から見つける。
- 52(因数分解)
  - 因数分解して計算を簡単にする
- 55(定数倍を見積もる):
  - 低数倍の大きさによってACできたりできなかったりする。
  - pythonの場合でcombinationをつかうばあい、リストでそのまま取り出すようにしないと死ぬ。
- 56(DP復元):
  - 元の経路を辿る必要がある場合は求めた後逆順で追うことを考える。
  - 本問は直接値に選択した記号を持つことで解決できてしまうが...
- 58(周期生)：
  - あまりを使う問題では周期性を利用して最後の値を求めることができないか検討しよう
- 60(最長増加部分列):
  - 困った時はここを参照https://qiita.com/python_walker/items/d1e2be789f6e7a0851e5
  - 愚直に最長の列を求めようとするとn2のオーダになってしまうが、更新する各aiを更新するのは高々DPのうちの１箇所であり、
  - DPのテーブルは単調増加であることに着目すると、更新場所は二分探索により求めることができるため、NlogNの計算量になる。
  - DPテーブルが意味するのはあくまでiこ連続する部分列の最小の値
    - 573289
    - 5 7 8 9が最終的なテーブルになる
    - 途中 2 7 のようなテーブルになるがあくまで1個の連結した数列の最小値は２であり、27という連続が作れることを意味しているわけではない。７になるのは 57の部分列を作った時。
- 61(deque)
  - dequeを使うことで計算量を落とす、ライブラリでもあるし自前で挿入時にtopとtailを動かせば良い
- 63(変な制約に注意)
  - 明らかに少ない制約などは全探索できないかみてみる。
- 64(階差を考える)
  - 隣接区間の差に注目することで解ける
- 66(期待値の線形性)
  - 数列などでは全ての数列のパターンではなく、単純に２値の値の代償などで決定される場合、期待値の線形生が利用できる。
  - 和の期待値は期待値の和。確率変数が独立でない場合も同様。
  - 積の期待値は期待値の積も、確率変数が独立である場合は同様である。
- 68(クエリ先よみ)
  - 本問題では、クエリの順番に答えるのではなくて、一度読み込んで完成系から復元をさせていく手順を踏む。
  - 一種類のクエリを先読みするだけではなくLiなどの変数が小さい順に処理したり、場合によっては木やグラフの問題に適用したりするそう。
  - 今回の場合先に繋がりを読み取り。a = 0で仮置きした場合に、各クエリに対しての差分を適用させることで答えをO(1)で出している
- 70(マンハッタン、x,y を独立に考える)
  - 今回は回転させる必要なし
  - 絶対値の和の最小は配列の**中央値**である。
- 72(バックトラック)：
  - 全探索できそうかの感覚と、バックトラックと呼ばれる、だめなら一手戻る再起の実装ができるかどうか。
- 75(√nの素因数分解)
- 76(円環は二倍して広げる)
  - 実戦では尺取り法で実装(N)
  - Lを決め打ちRを二分探索から拾う方法もある（NlogN)
  - 事前に広げた時に各店までの累積話をとっておくことでLRを決め打った時の値をO(1）で計算できる。
- 78(グラフの基本)
  - 基本は隣接行列N^2必要、 隣接リスト、Nだけしかいらない。
- 79(操作順序によらない)
  - ある操作を任意の回数だけ行う場合、簡単なシミュレーションをしてみて、操作順序によらないことを確かめてみると開放へ近づく。
- 81(データを二次元にプロット、累積和)
  - データが２種類ある場合はグラフ上にプロットしてみることを考える。
  - 
- 82(逆元とこんなんのぶんかつ)：
  - 逆元を利用する場合基本的にはModintのライブラリを使って計算すれば問題ない。
- 84(らんれんぐす、るいせきていきに)
  - 実践的には尺取りを使った、考え方的には累積法に似ているかも
  - 蘭レングスは、世事象を使った考え方
- 85(約数を扱う問題は要注意、全探索の可能性)
  - 約数の数は、元の値に比べて非常に小さい。
  - 約数を扱う場合ライブラリに、約数を列挙するものと、素因数分解して、その個数で扱えるに種類があるため適宜使い分ける。
- 86(bitごとに独立に考える)
  - bit演算(or や and)を含むものは、なるべく各bitごとに独立に考えるとうまくいくことが多い。
  - その際、制約をよく見てアリエルパターンが各ビットごとに全探索できないかのオーダーも計算してみること。
  - 調べる桁数 * 条件の全探索数 * 全条件
- 87(境界値の二分探索、わーシャルフロイド)要復習（なぜかACしている）
  - Nが小さく（500 < N)、全部の店へのコスト最小値を求める場合などに必要


## 全体進行率

- 59/90
- レベル2
  - 10/10
- レベル3
  - 20/20
- レベル4
  - 13/14
- レベル5
  - 16/17
- レベル6
  - 0/14
- レベル7
  - 0/15
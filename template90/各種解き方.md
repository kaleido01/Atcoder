

# 全探索

## 基本は全通りを調べられないかを考える
- 1(答えで二分探索)
  - 実装は中身を参照のこと
- 2(小さい制約は全探索、bit全探索)
- 3(木の直径は最短距離計算を２回行う)
  - N頂点、N-1の辺の連結なグラフ
  - 頂点u-vにいく単純パスはただ１つだけ存在する
  - 頂点uとvを双方向に結ぶ辺を一本追加するとき閉路は１つ存在し、長さはu->vの単純パスの長さ＋１

- 4(前計算, 累積和)
- 7(ソートからの二分探索)
- 10(区間の総和->累積和)
- 12(連結判定はUnion -Find)
- 14(ソートして貪欲法)
- 16(全探索工夫)
- 18(三角関数を使いこなす)
  - math.sin, math.cos, math.pi, math.atan...
- 20(整数で考えて誤差を生まないように)
- 22(最大公約数はユークリッド)
- 24(偶奇を考えて、パリティを考慮する)
- 27(map, 辞書を使いこなす)
- 28
  - stackで実装するやり方（再帰制限を回避)
  - 再帰処理で実装
- 32(小さい制約は順列全探索)
  - list(itertools.permutations([i for i in range(n)]))
- 33(コーナーケースに気をつける)
  - 特定の場合に条件から外れる場合を抜け漏れないように
- 34（単調性を利用した尺取りほう)
- 36(マンハッタン距離は４５度回転)
  - X' = x - y
  - Y' = x + y
  - 回転後の二点間のマンハッタン距離は max(|X' - px|, |y' - py|)
- 37(DPをセグメント木で高速化)
  - 超難しい
  - D Pで気をつけるべきは初期値、不可能な場合に判別できるように−１などで全体を初期化する
  - ただし、この時、〇番目の値を用いる場合はその列を０で初期化しておくなど、使えるけど使っていない状態と、そもそもその枠を使えないケースを区別しておく。
  - テーマは３重ループの中身をよくみると、その中での最大値を取得して値を更新するため、DPの一次元をセグメント木で管理することにより、最大値の取得を O(Log W)で行うことで計算量を削減するのがポイントになる。
- 38(オーバーフローに注意)：
  - 最小公倍数を求める問題で、最小こう倍数は 最大公約数をgcdを利用して a * b // gcdで求めることができる
  - この時gcdはユークリッドの互除法を利用することで、log(a+b)の計算量で求められる。
  - Pythonではa*bの時にオーバーフローしても多倍数を扱えるので問題ない。
- 39(答えへの貢献度を考える)
  - 和の形の数え上げを見たら主客転倒ができないかを念頭に置いて考える
  - 木DPという部分木の足し合わせについて考える。
  - 主客転置
    - 問題文で提示された求め方を別の意味に捉える。
  - コストが積の形になっているものも何らかの和の形に落とし込むと上手く行く場合がある。
- 42(9の倍数に着目)
  - 要復習
  - わかったようでなかなか完璧に理解し切れていない。
  - 今回のケースだと桁の和がXの時のDPをとる
  - XのDPになるためには１〜９個前のDPを加算すればいい→なぜ？
    - 例えば　３のケースは 111 21 12 3の４パターンある
    - 4のケースを作ろうとすると 3, 2, 1, 0 のケースの足し合わせである。
    - 例えば0のケースは４をつけるだけなので１通り
    - 1のケースは1に対して先頭につけるか後ろにつけるかで 1 3 or 3 1のにパターンあるが、これを先頭にのみつけていくことを考えれば重複しない(3,1のみをとる)
    - 1,3のケースは　3の時のケースでカバーできる（３は　3 12 21 111の４パターンあり、その先頭のパターンが該当する。
    - つまり結局のところ直前の和の作り方でできた整数の先頭に１〜９のいずれかを足すことで目的の値になる。
- 43(ダイクストラと0-1BFS)
  - ダイクストラは勉強
  - 01BFS辺の重みを１として扱う。この時、辺の重み１を使用した場合、なるべくコストを小さくしたい時にはすぐに探索する必要がないため後回しでappendrightにしておく。
  - また、今回の問題では向きが重要であるため、同じコストでもその地点を通過するときにどの向きで来たかでそれ以降のコストが変動する場合があるため、異なる向きの同じコストのパターンは次回のキューに差し込む必要がある。
- 44(見かけの変化を記録する)
  - 配列の位置を変換するようなものについてその交換した回数などを記録しておくだけで答えられる問題がある。
- 46(同じ意味のものをまとめる)
  - 今回は46で割ったあまりに注目して10^9まである範囲を46までの範囲に絞り込む。
- 48(上階と下界を見積る)
  - これ以上の答えが絶対にありえないような上階値を考えてみる。その後、実際に上階とな流答えや方法を構成する
- 52(因数分解)
  - 因数分解して計算を簡単にする
- 55(定数倍を見積もる):
  - 低数倍の大きさによってACできたりできなかったりする。
  - pythonの場合でcombinationをつかうばあい、リストでそのまま取り出すようにしないと死ぬ。
- 58(周期生)：
  - あまりを使う問題では周期性を利用して最後の値を求めることができないか検討しよう
- 61(deque)
  - dequeを使うことで計算量を落とす、ライブラリでもあるし自前で挿入時にtopとtailを動かせば良い
- 63(変な制約に注意)
  - 明らかに少ない制約などは全探索できないかみてみる。
- 64(階差を考える)
  - 隣接区間の差に注目することで解ける
- 70(マンハッタン、x,y を独立に考える)
  - 今回は回転させる必要なし
  - 絶対値の和の最小は配列の**中央値**である。
- 72(バックトラック)：
  - 全探索できそうかの感覚と、バックトラックと呼ばれる、だめなら一手戻る再起の実装ができるかどうか。
- 75(√nの素因数分解)
- 76(円環は二倍して広げる)
  - 実戦では尺取り法で実装(N)
  - Lを決め打ちRを二分探索から拾う方法もある（NlogN)
  - 事前に広げた時に各店までの累積話をとっておくことでLRを決め打った時の値をO(1）で計算できる。
- 78(グラフの基本)
  - 基本は隣接行列N^2必要、 隣接リスト、Nだけしかいらない。
- 79(操作順序によらない)
  - ある操作を任意の回数だけ行う場合、簡単なシミュレーションをしてみて、操作順序によらないことを確かめてみると開放へ近づく。
- 82(逆元とこんなんのぶんかつ)：
  - 逆元を利用する場合基本的にはModintのライブラリを使って計算すれば問題ない。
- 84(らんれんぐす、るいせきていきに)
  - 実践的には尺取りを使った、考え方的には累積法に似ているかも
  - 蘭レングスは、世事象を使った考え方
- 85(約数を扱う問題は要注意、全探索の可能性)
  - 約数の数は、元の値に比べて非常に小さい。
  - 約数を扱う場合ライブラリに、約数を列挙するものと、素因数分解して、その個数で扱えるに種類があるため適宜使い分ける。


## 全体進行率

- 37/90
- レベル2
  - 10/10
- レベル3
  - 20/20
- レベル4
  - 12/14
- レベル5
  - 3/17
- レベル6
  - 0/14
- レベル7
  - 0/15
# 全探索

## 基本は全通りを調べられないかを考える
- 全探索
  - bit演算
  - ((i >> j) &1 ) iをj回右に移動させた時に 1 であることを示す。
- 深さ優先探索(Depth first search)
  - stackで実装するやり方（再帰制限を回避)
  - 再帰処理で実装
- Union-Find
  - 結合時小さい方を大きい方に結合することで最悪計算量が改善されることがある。
  - 無駄に２次元配列を使いそうな時はdictを使うと良いかもしれない。
- ダイクストラ
  - 最短経路問題で使用されるアルゴリズム
  - 負の重みが存在する場合は最小の部分の確定が不確定になるため使用できず、わーシャルフロイドを用いる
  - スタートから辿れる地点の重みを計算して、最小の部分から順番に確定させていく。
  - 最小の部分の取り出しに優先度付きキュー(挿入取り出しにlogn)
  - 各エッジは一度ずつ計算されて確定頂点の取り出しにlogV計算量はElogV

## 計算量
- math.infについて
  - メモリの要領として時間ギリギリになる場合math.infを使用するとオーバーする可能性があるため、現実的に超えないライン程度にINFを設定しておくと若干の計算量削減になる。
- Python, pypyについて
  - 基本pypyで通せばいいが、再帰関数を使ってる場合はPythonで通した方がいいかも
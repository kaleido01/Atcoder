
# 第二引数でソートをしてくれる
l = [(3, 4),(1, 1),(3, 9),(3, 5)]
l.sort(key= lambda array: array[1])


#　文字列逆順処理
s = "erg49tuaef"
s[::-1]


# 優先度付きキューの基本
# heapq.heapify(リスト)でリストを優先度付きキューに変換。
# heapq.heappop(優先度付きキュー (=リスト) )で優先度付きキューから最小値を取り出す。
# heapq.heappush(優先度付きキュー (=リスト) , 挿入したい要素)で優先度付きキューに要素を挿入。

a = [1, 6, 8, 0, -1]
heapq.heapify(a)  # リストを優先度付きキューへ
print(a)
# 出力: [-1, 0, 8, 1, 6] (優先度付きキューとなった a)

# 文字列結合
s = "".join(t)

#０除算に気をつけよう

# 改行出力は下記でもいける.正確には空白出力だが。
print(*ans)


# 辞書にはキーとして　タプルであれば持たせることができる。座標を記録してo(1)で取得できたりすることも。
dic = {}
for i in range(n):

  dic[(1,2)] = True

# n個の配列のうちk番めずつに制約がかかる場合、グループをk個に分けて処理する手法。

# 計算誤差について
# f(A) を、

# 実数 x=(100+t)/100×A を求める
# ⌊x⌋ を求める
# というような手順で計算した場合、正しく f(A) が計算できない可能性があります。例えば

# Python で x = int(113 / 100 * 100)
# C++ で int x = 113 / 100.0 * 100;
# といった計算を行うと、x=112 という「誤った計算結果」になっていることが確かめられます。

# 実数 x がぴったり整数であった場合には任意の正の実数 ε>0 に対して ⌊x⌋
# 
# =⌊x−ε⌋ となるので、x を絶対誤差 ε 以下で計算した場合であっても ⌊x⌋ の値が誤って計算されてしまう可能性があります。この問題は、いくら計算精度を高くしても解消されません。切り捨て後の正確な値が必要なのであれば、計算の方法を改める必要があります。

# 今回の問題・制約では、

# 整数型の切り捨て除算を用いて、(100+t)×A を 100 で割る形で f(A) を計算する
# x=(100+t)/100×A を小数で計算したあと、小さな値を加えてから切り捨てる（⌊x⌋ の代わりに ⌊x+0.001⌋ などを計算する）
# のような形で f(A) を計算すると、正しく f(A) が計算できます。



# グラフ理論
# パスグラフ　　次数が２以下（頂点から伸びるへんの数）、サイクルがない（木構造であること）
# 木構造　サイクルがない
# 強成分連結分解
# トポロジカルソート: 辺の向きに沿うように一列に並べること（依存関係を解決処理）
# DAG(directed Acyclied Graph）有向グラフで、サイクルがない。どの頂点から出発してもその頂点には戻ってこれないこと。トポロジカルソートが可能
# any: